// server.js - Application AirLight compl√®te avec IA et M√©t√©o (ROUTES SANS /API)
const express = require('express');
const http = require('http');
const mongoose = require('mongoose');
const cors = require('cors');
const passport = require('passport');
const session = require('express-session');
const MongoStore = require('connect-mongo');
const rateLimit = require('express-rate-limit');
const helmet = require('helmet');
const compression = require('compression');
require('dotenv').config();

// Import des configurations et services
require('./config/passport');
const schedulerService = require('./services/SchedulerService');
const { AlertMiddleware, injectAlertMiddleware } = require('./middleware/alertMiddleware');

// üå§Ô∏è Import du service m√©t√©o
const WeatherService = require('./services/WeatherService');

// Import des routes
const authRoutes = require('./routes/auth');
const alertRoutes = require('./routes/alerts');
const sensorRoutes = require('./routes/sensors');
const predictionRoutes = require('./routes/predictions');
const adminRoutes = require('./routes/admin');
const weatherRoutes = require('./routes/weather');

const app = express();
const server = http.createServer(app);

// üå§Ô∏è Initialiser le service m√©t√©o
const weatherService = new WeatherService();

// Initialiser AlertMiddleware
AlertMiddleware.initialize(server);

// Middlewares de s√©curit√© et performance
app.use(helmet({
  contentSecurityPolicy: {
    directives: {
      defaultSrc: ["'self'"],
      styleSrc: ["'self'", "'unsafe-inline'"],
      scriptSrc: ["'self'"],
      imgSrc: ["'self'", "data:", "https:"],
    },
  },
}));

app.use(compression());

// Rate limiting
const limiter = rateLimit({
  windowMs: parseInt(process.env.RATE_LIMIT_WINDOW_MS) || 15 * 60 * 1000,
  max: parseInt(process.env.RATE_LIMIT_MAX_REQUESTS) || 100,
  message: {
    success: false,
    message: 'Trop de requ√™tes, r√©essayez plus tard'
  }
});

app.use('/api/', limiter);

// Middlewares de base
app.use(express.json({ 
  limit: process.env.MAX_FILE_SIZE ? 
    parseInt(process.env.MAX_FILE_SIZE) : 
    '10mb' 
}));
app.use(express.urlencoded({ extended: true }));

// Configuration CORS
const corsOptions = {
  origin: process.env.CORS_ORIGIN?.split(',') || ['http://localhost:4200','http://localhost:3000'],
  credentials: true,
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS', 'PATCH'],
  allowedHeaders: ['Content-Type', 'Authorization']
};
app.use(cors(corsOptions));

// Middleware pour injecter AlertMiddleware
app.use(injectAlertMiddleware);

// Configuration des sessions
app.use(session({
  secret: process.env.SESSION_SECRET || 'votre-session-secret-changez-moi',
  resave: false,
  saveUninitialized: false,
  store: MongoStore.create({
    mongoUrl: process.env.MONGODB_URI,
    ttl: 24 * 60 * 60
  }),
  cookie: {
    secure: process.env.NODE_ENV === 'production',
    maxAge: 24 * 60 * 60 * 1000
  }
}));

// Initialisation de Passport
app.use(passport.initialize());
app.use(passport.session());

// Connexion √† MongoDB
mongoose.connect(process.env.MONGODB_URI || 'mongodb://localhost:27017/airlight')
  .then(() => {
    console.log('‚úÖ Connexion MongoDB r√©ussie');
    
    // üå§Ô∏è Tester le service m√©t√©o apr√®s la connexion DB
    weatherService.testConnection().then(result => {
      if (result.success) {
        console.log('‚úÖ Service m√©t√©o initialis√© avec succ√®s');
      } else {
        console.log('‚ö†Ô∏è Service m√©t√©o non disponible:', result.error);
        if (result.recommendation) {
          console.log('üí° Recommandation:', result.recommendation);
        }
      }
    });
    
    // Initialiser le scheduler apr√®s la connexion DB
    setTimeout(() => {
      schedulerService.initialize();
    }, 2000);
  })
  .catch((error) => {
    console.error('‚ùå Erreur connexion MongoDB:', error.message);
  });

// üö® Routes principales SANS pr√©fixe /api (selon votre demande)
app.use('/auth', authRoutes);
app.use('/alerts', alertRoutes);
app.use('/sensors', sensorRoutes);
app.use('/predictions', predictionRoutes);
app.use('/admin', adminRoutes);
app.use('/weather', weatherRoutes); // üå§Ô∏è Routes m√©t√©o ajout√©es

// Route de sant√© compl√®te avec m√©t√©o
app.get('/health', async (req, res) => {
  try {
    // V√©rifier les services
    const PredictionService = require('./services/PredictionService');
    const predictionService = new PredictionService();
    const aiHealth = await predictionService.checkAIServiceHealth();
    
    // üå§Ô∏è V√©rifier le service m√©t√©o
    const weatherHealth = await weatherService.testConnection();
    
    const health = {
      status: 'OK',
      timestamp: new Date(),
      services: {
        database: mongoose.connection.readyState === 1 ? 'Connected' : 'Disconnected',
        websocket: AlertMiddleware ? 'Active' : 'Inactive',
        scheduler: schedulerService.isRunning ? 'Running' : 'Stopped',
        ai_service: aiHealth.available ? 'Available' : 'Unavailable',
        weather_service: weatherHealth.success ? 'Available' : 'Unavailable', // üå§Ô∏è
        connectedClients: AlertMiddleware ? AlertMiddleware.getConnectionStats().connectedClients : 0
      },
      scheduler_jobs: schedulerService.getJobsStatus(),
      ai_service_detail: aiHealth,
      weather_service_detail: weatherHealth // üå§Ô∏è
    };
    
    const statusCode = (
      health.services.database === 'Connected' && 
      health.services.scheduler === 'Running'
    ) ? 200 : 503;
    
    res.status(statusCode).json(health);
    
  } catch (error) {
    res.status(503).json({
      status: 'ERROR',
      message: error.message,
      timestamp: new Date()
    });
  }
});

// Route principale avec documentation compl√®te incluant m√©t√©o
app.get('/', (req, res) => {
  res.json({
    name: 'AirLight API',
    description: 'Syst√®me intelligent de surveillance de la qualit√© de l\'air avec IA pr√©dictive et m√©t√©o',
    version: '1.0.0',
    features: [
      'üîê Authentification Google OAuth + JWT',
      'üö® Syst√®me d\'alertes temps r√©el',
      'üìä Collecte donn√©es multi-capteurs (S√©n√©gal)',
      'ü§ñ Pr√©dictions IA avec Machine Learning',
      'üå§Ô∏è Service m√©t√©o int√©gr√© avec corr√©lation qualit√© air', // üå§Ô∏è
      'üì° WebSocket temps r√©el',
      'üïê Scheduler automatis√©',
      'üë®‚Äçüíº Interface administrateur'
    ],
    endpoints: {
      authentication: {
        'POST /auth/register': 'Inscription utilisateur',
        'POST /auth/login': 'Connexion email/password',
        'GET /auth/google': 'Connexion Google OAuth',
        'GET /auth/me': 'Profil utilisateur connect√©',
        'POST /auth/logout': 'D√©connexion'
      },
      sensors: {
        'GET /sensors': 'Liste des capteurs avec statuts',
        'GET /sensors/:sensorId/data': 'Donn√©es historiques d\'un capteur',
        'GET /sensors/:sensorId/latest': 'Derni√®res mesures d\'un capteur',
        'GET /sensors/:sensorId/weather': 'M√©t√©o pour un capteur sp√©cifique', // üå§Ô∏è
        'GET /sensors/weather/dashboard': 'Dashboard m√©t√©o tous capteurs', // üå§Ô∏è
        'POST /sensors/data': 'Recevoir donn√©es depuis ESP32',
        'POST /sensors/sync': 'Synchroniser avec AirGradient (admin)',
        'GET /sensors/stats/global': 'Statistiques globales tous capteurs'
      },
      alerts: {
        'GET /alerts': 'Liste des alertes avec filtres',
        'GET /alerts/active': 'Alertes actives uniquement',
        'GET /alerts/stats': 'Statistiques des alertes',
        'POST /alerts/check': 'V√©rifier et cr√©er alertes',
        'PATCH /alerts/:id/acknowledge': 'Acquitter une alerte',
        'PATCH /alerts/:id/resolve': 'R√©soudre une alerte',
        'POST /alerts/bulk/acknowledge': 'Acquitter plusieurs alertes'
      },
      predictions: {
        'GET /predictions/sensors': 'Capteurs avec pr√©dictions disponibles',
        'GET /predictions/:sensorId': 'Pr√©dictions d\'un capteur',
        'POST /predictions/:sensorId/generate': 'G√©n√©rer nouvelles pr√©dictions',
        'POST /predictions/batch/generate': 'Pr√©dictions tous capteurs (admin)',
        'GET /predictions/:sensorId/accuracy': '√âvaluer pr√©cision pr√©dictions',
        'GET /predictions/stats/global': 'Statistiques globales IA',
        'GET /predictions/ai-service/health': '√âtat du service IA'
      },
      // üå§Ô∏è Endpoints m√©t√©o
      weather: {
        'GET /weather/current': 'M√©t√©o actuelle (city, lat, lon)',
        'GET /weather/forecast': 'Pr√©visions m√©t√©o jusqu\'√† 5 jours',
        'GET /weather/cities': 'M√©t√©o pour toutes les villes avec capteurs',
        'GET /weather/air-quality-forecast': 'Impact m√©t√©o sur qualit√© air',
        'GET /weather/search': 'Recherche de villes',
        'GET /weather/impact/:sensorId': 'Impact m√©t√©o sur capteur (auth)',
        'GET /weather/dashboard': 'Tableau de bord m√©t√©o temps r√©el',
        'GET /weather/stats': 'Statistiques du service m√©t√©o',
        'GET /weather/test': 'Test connexion API m√©t√©o (admin)'
      },
      admin: {
        'GET /admin/dashboard': 'Tableau de bord administrateur',
        'GET /admin/scheduler/status': '√âtat du scheduler',
        'POST /admin/scheduler/run/:jobName': 'Ex√©cuter job manuellement',
        'POST /admin/scheduler/sync-now': 'Synchronisation forc√©e',
        'GET /admin/users': 'Gestion des utilisateurs',
        'PATCH /admin/users/:id/role': 'Modifier r√¥le utilisateur'
      },
      system: {
        'GET /health': '√âtat de sant√© complet du syst√®me',
        'GET /websocket/stats': 'Statistiques connexions WebSocket'
      }
    },
    websocket: {
      url: `ws://localhost:${process.env.PORT || 3000}/socket.io`,
      events: {
        client_to_server: [
          'authenticate - S\'authentifier avec token JWT',
          'subscribe_sensor - S\'abonner aux alertes d\'un capteur',
          'unsubscribe_sensor - Se d√©sabonner d\'un capteur',
          'ping - Test de connexion'
        ],
        server_to_client: [
          'authenticated - Confirmation d\'authentification',
          'new_alert - Nouvelle alerte cr√©√©e',
          'sensor_alert - Alerte sp√©cifique √† un capteur',
          'alert_resolved - Alerte r√©solue',
          'active_alerts - Liste des alertes actives',
          'system_stats - Statistiques syst√®me temps r√©el',
          'predictions_update - Nouvelles pr√©dictions disponibles',
          'weather_update - Mise √† jour m√©t√©o', // üå§Ô∏è
          'weather_alert - Alerte m√©t√©o impactant qualit√© air', // üå§Ô∏è
          'pong - R√©ponse au ping'
        ]
      }
    },
    ai_predictions: {
      service_url: process.env.FLASK_API_URL || 'http://localhost:5000',
      features: [
        'Pr√©dictions PM2.5/AQI jusqu\'√† 72h',
        'Machine Learning avec Random Forest',
        '√âvaluation automatique de pr√©cision',
        'Alertes pr√©dictives intelligentes',
        'Mode d√©grad√© si service IA indisponible'
      ],
      supported_parameters: ['pm25', 'pm10', 'co2', 'temperature', 'humidity', 'tvoc', 'nox']
    },
    // üå§Ô∏è Nouvelle section m√©t√©o
    weather_service: {
      provider: 'OpenWeatherMap',
      api_configured: !!process.env.OPENWEATHER_API_KEY,
      features: [
        'M√©t√©o temps r√©el pour toutes les villes du S√©n√©gal',
        'Pr√©visions jusqu\'√† 5 jours',
        'Analyse impact m√©t√©o sur qualit√© de l\'air',
        'Corr√©lation vent/dispersion des polluants',
        'Alertes m√©t√©o affectant la pollution',
        'Support saison Harmattan',
        'Donn√©es en fran√ßais',
        'G√©olocalisation automatique des capteurs'
      ],
      supported_cities: [
        'Dakar', 'Saint-Louis', 'Thi√®s', 'Diourbel', 
        'Richard-Toll', 'Rufisque', 'Pikine'
      ],
      correlation_factors: [
        'Vitesse et direction du vent (dispersion)',
        'Humidit√© (suspension particules)',
        'Pression atmosph√©rique (inversion)',
        'Couverture nuageuse (photo-d√©gradation)',
        'Saison Harmattan (poussi√®re sah√©lienne)'
      ]
    },
    sensors_coverage: {
      country: 'S√©n√©gal',
      locations: [
        { name: 'Dakar', status: 'active', weather_available: true },
        { name: 'Saint-Louis', status: 'active', weather_available: true },
        { name: 'Thi√®s', status: 'active', weather_available: true },
        { name: 'Diourbel', status: 'active', weather_available: true },
        { name: 'Richard Toll', status: 'active', weather_available: true },
        { name: 'Rufisque', status: 'active', weather_available: true }
      ],
      data_sources: ['AirGradient', 'OpenAQ', 'ESP32'],
      weather_integration: 'OpenWeatherMap API' // üå§Ô∏è
    },
    scheduler_jobs: schedulerService.getJobsStatus()
  });
});

// Routes de test pour le d√©veloppement
if (process.env.NODE_ENV === 'development') {
  // Test complet du syst√®me avec m√©t√©o
  app.post('/test/system', async (req, res) => {
    try {
      const results = {
        timestamp: new Date(),
        tests: {}
      };
      
      // Test base de donn√©es
      results.tests.database = {
        status: mongoose.connection.readyState === 1 ? 'OK' : 'FAIL',
        collections: await mongoose.connection.db.listCollections().toArray()
      };
      
      // Test WebSocket
      results.tests.websocket = {
        status: AlertMiddleware ? 'OK' : 'FAIL',
        clients: AlertMiddleware ? AlertMiddleware.getConnectionStats() : null
      };
      
      // Test service IA
      const PredictionService = require('./services/PredictionService');
      const predictionService = new PredictionService();
      const aiHealth = await predictionService.checkAIServiceHealth();
      results.tests.ai_service = aiHealth;
      
      // üå§Ô∏è Test service m√©t√©o
      const weatherHealth = await weatherService.testConnection();
      results.tests.weather_service = weatherHealth;
      
      // Test scheduler
      results.tests.scheduler = {
        status: schedulerService.isRunning ? 'OK' : 'FAIL',
        jobs: schedulerService.getJobsStatus()
      };
      
      res.json({
        success: true,
        message: 'Tests syst√®me effectu√©s',
        results
      });
      
    } catch (error) {
      res.status(500).json({
        success: false,
        message: 'Erreur lors des tests syst√®me',
        error: error.message
      });
    }
  });
  
  // üå§Ô∏è Test sp√©cifique m√©t√©o
  app.post('/test/weather', async (req, res) => {
    try {
      console.log('üå§Ô∏è Test complet du service m√©t√©o...');
      
      const weatherTests = {
        connection: await weatherService.testConnection(),
        current_dakar: await weatherService.getCurrentWeather('Dakar'),
        forecast_dakar: await weatherService.getForecast('Dakar', null, null, 3),
        all_cities: await weatherService.getWeatherForAllSensorCities(),
        air_quality_analysis: await weatherService.getAirQualityForecast('Dakar'),
        search_test: await weatherService.searchCity('Thi'),
        stats: weatherService.getServiceStats()
      };
      
      res.json({
        success: true,
        message: 'üå§Ô∏è Tests m√©t√©o termin√©s',
        tests: weatherTests
      });
      
    } catch (error) {
      res.status(500).json({
        success: false,
        message: 'Erreur lors des tests m√©t√©o',
        error: error.message
      });
    }
  });
  
  // Route pour d√©clencher une d√©mo compl√®te avec m√©t√©o
  app.post('/demo/full', async (req, res) => {
    try {
      console.log('üé¨ D√©marrage d√©mo compl√®te AirLight avec m√©t√©o...');
      
      const demo_results = {
        step1_data_sync: null,
        step2_weather_sync: null, // üå§Ô∏è
        step3_alert_creation: null,
        step4_prediction_generation: null,
        step5_weather_correlation: null, // üå§Ô∏è
        step6_websocket_broadcast: null
      };
      
      // √âtape 1: Synchronisation de donn√©es capteurs
      try {
        const syncResult = await schedulerService.runJobManually('sync');
        demo_results.step1_data_sync = { success: true, result: syncResult };
      } catch (error) {
        demo_results.step1_data_sync = { success: false, error: error.message };
      }
      
      // üå§Ô∏è √âtape 2: Synchronisation m√©t√©o
      try {
        const weatherData = await schedulerService.runJobManually('weather');
        demo_results.step2_weather_sync = { success: weatherData.success, result: weatherData };
      } catch (error) {
        demo_results.step2_weather_sync = { success: false, error: error.message };
      }
      
      // √âtape 3: Cr√©ation d'alerte de test
      try {
        const Alert = require('./models/Alert');
        const testAlert = new Alert({
          sensorId: 'DEMO_SENSOR',
          alertType: 'pollution_spike',
          severity: 'unhealthy', // üîß Corrig√©: utiliser nouveaux niveaux
          qualityLevel: 'very_poor',
          referenceStandard: 'WHO_2021',
          message: 'üé¨ D√âMO - Pic de pollution d√©tect√©: PM2.5 √† 95.2 ¬µg/m¬≥',
          data: {
            pollutants: {
              pm25: { value: 95.2, unit: '¬µg/m¬≥', threshold: 55, standard: 'WHO_2021' }
            },
            healthInfo: {
              impact: 'Malsain pour tous - Action requise',
              recommendations: ['Restez √† l\'int√©rieur', 'Fermez les fen√™tres', 'Utilisez un purificateur']
            },
            location: 'Capteur D√©mo Dakar'
          }
        });
        
        await testAlert.save();
        
        // Diffuser l'alerte
        const { triggerAlert } = require('./middleware/alertMiddleware');
        triggerAlert(testAlert);
        
        demo_results.step3_alert_creation = { success: true, alert: testAlert };
      } catch (error) {
        demo_results.step3_alert_creation = { success: false, error: error.message };
      }
      
      // √âtape 4: G√©n√©ration de pr√©dictions
      try {
        const predResult = await schedulerService.runPredictionJobManually();
        demo_results.step4_prediction_generation = { success: true, result: predResult };
      } catch (error) {
        demo_results.step4_prediction_generation = { success: false, error: error.message };
      }
      
      // üå§Ô∏è √âtape 5: Corr√©lation m√©t√©o/qualit√© air
      try {
        const weatherAnalysis = await weatherService.getAirQualityForecast('Dakar');
        demo_results.step5_weather_correlation = { success: weatherAnalysis.success, result: weatherAnalysis };
      } catch (error) {
        demo_results.step5_weather_correlation = { success: false, error: error.message };
      }
      
      // √âtape 6: Diffusion stats WebSocket
      try {
        AlertMiddleware.broadcastSystemStats({
          type: 'demo_complete',
          message: 'üé¨ D√©mo AirLight avec m√©t√©o termin√©e avec succ√®s',
          demo_results,
          timestamp: new Date()
        });
        
        // üå§Ô∏è Diffuser aussi update m√©t√©o
        if (demo_results.step2_weather_sync?.success) {
          schedulerService.broadcastWeatherUpdate({
            type: 'weather_demo',
            message: 'üå§Ô∏è Donn√©es m√©t√©o d√©mo mises √† jour',
            data: demo_results.step2_weather_sync.result,
            timestamp: new Date()
          });
        }
        
        demo_results.step6_websocket_broadcast = { success: true };
      } catch (error) {
        demo_results.step6_websocket_broadcast = { success: false, error: error.message };
      }
      
      console.log('üé¨ D√©mo compl√®te avec m√©t√©o termin√©e');
      
      res.json({
        success: true,
        message: 'üé¨ D√©mo compl√®te AirLight avec m√©t√©o ex√©cut√©e',
        demo_results,
        next_steps: [
          '1. V√©rifiez les alertes cr√©√©es dans /alerts',
          '2. Consultez les pr√©dictions dans /predictions/sensors',
          '3. Explorez la m√©t√©o dans /weather/dashboard', // üå§Ô∏è
          '4. Analysez corr√©lation m√©t√©o/pollution dans /weather/cities', // üå§Ô∏è
          '5. Observez les stats temps r√©el via WebSocket',
          '6. Acc√©dez au dashboard admin dans /admin/dashboard'
        ]
      });
      
    } catch (error) {
      console.error('‚ùå Erreur d√©mo:', error);
      res.status(500).json({
        success: false,
        message: 'Erreur lors de la d√©mo',
        error: error.message
      });
    }
  });
}

// Gestion des erreurs 404
app.use((req, res) => {
  res.status(404).json({
    success: false,
    message: 'Route non trouv√©e',
    suggestion: 'Consultez la documentation sur GET /',
    available_routes: [
      '/auth/*', '/sensors/*', '/alerts/*', 
      '/predictions/*', '/admin/*', '/weather/*', '/health' // üå§Ô∏è
    ]
  });
});

// Middleware de gestion des erreurs globales
app.use((error, req, res, next) => {
  console.error('‚ùå Erreur serveur:', error);
  
  // Erreurs de validation MongoDB
  if (error.name === 'ValidationError') {
    return res.status(400).json({
      success: false,
      message: 'Donn√©es invalides',
      details: Object.values(error.errors).map(e => e.message)
    });
  }
  
  // Erreurs de cast MongoDB
  if (error.name === 'CastError') {
    return res.status(400).json({
      success: false,
      message: 'Format d\'ID invalide'
    });
  }
  
  // Erreurs JWT
  if (error.name === 'JsonWebTokenError') {
    return res.status(401).json({
      success: false,
      message: 'Token invalide'
    });
  }
  
  // Erreur g√©n√©rique
  res.status(500).json({
    success: false,
    message: process.env.NODE_ENV === 'development' ? error.message : 'Erreur serveur interne'
  });
});

// Gestion de l'arr√™t gracieux
process.on('SIGTERM', gracefulShutdown);
process.on('SIGINT', gracefulShutdown);

function gracefulShutdown(signal) {
  console.log(`\nüì¥ Signal ${signal} re√ßu, arr√™t gracieux...`);
  
  // Arr√™ter le scheduler
  schedulerService.stopAll();
  
  // Fermer le serveur
  server.close(() => {
    console.log('üîå Serveur HTTP ferm√©');
    
    // Fermer la connexion MongoDB
    mongoose.connection.close(false, () => {
      console.log('üóÑÔ∏è Connexion MongoDB ferm√©e');
      process.exit(0);
    });
  });
  
  // Forcer l'arr√™t apr√®s 10 secondes
  setTimeout(() => {
    console.error('‚ö†Ô∏è Arr√™t forc√© apr√®s timeout');
    process.exit(1);
  }, 10000);
}

// D√©marrage du serveur
const PORT = process.env.PORT || 3000;
server.listen(PORT, () => {
  console.log('\nüöÄ =================================');
  console.log('üåü AirLight API d√©marr√©e avec succ√®s');
  console.log('üöÄ =================================');
  console.log(`üì° Serveur: http://localhost:${PORT}`);
  console.log(`üîó Google OAuth: ${process.env.GOOGLE_CALLBACK_URL || 'Non configur√©'}`);
  console.log(`üåê WebSocket: ws://localhost:${PORT}/socket.io`);
  console.log(`ü§ñ Service IA: ${process.env.FLASK_API_URL || 'http://localhost:5000'}`);
  console.log(`üå§Ô∏è Service m√©t√©o: ${process.env.OPENWEATHER_API_KEY ? 'OpenWeatherMap configur√©' : 'Non configur√©'}`); // üå§Ô∏è
  console.log(`üìä Dashboard: http://localhost:${PORT}/admin/dashboard`);
  console.log(`üå§Ô∏è M√©t√©o: http://localhost:${PORT}/weather/dashboard`); // üå§Ô∏è
  console.log(`üè• Sant√©: http://localhost:${PORT}/health`);
  
  if (process.env.NODE_ENV === 'development') {
    console.log(`üé¨ D√©mo: http://localhost:${PORT}/demo/full`);
    console.log(`üå§Ô∏è Test m√©t√©o: http://localhost:${PORT}/test/weather`); // üå§Ô∏è
    console.log('üîß Mode d√©veloppement - Routes de test disponibles');
  }
  
  console.log('üöÄ =================================\n');
});

module.exports = server; 