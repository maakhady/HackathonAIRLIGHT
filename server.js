// server.js - Application AirLight compl√®te avec IA
const express = require('express');
const http = require('http');
const mongoose = require('mongoose');
const cors = require('cors');
const passport = require('passport');
const session = require('express-session');
const MongoStore = require('connect-mongo');
const rateLimit = require('express-rate-limit');
const helmet = require('helmet');
const compression = require('compression');
require('dotenv').config();

// Import des configurations et services
require('./config/passport');
const schedulerService = require('./services/SchedulerService');
const { AlertMiddleware, injectAlertMiddleware } = require('./middleware/alertMiddleware');

// Import des routes
const authRoutes = require('./routes/auth');
const alertRoutes = require('./routes/alerts');
const sensorRoutes = require('./routes/sensors');
const predictionRoutes = require('./routes/predictions');
const adminRoutes = require('./routes/admin');

const app = express();
const server = http.createServer(app);

// Initialiser AlertMiddleware
AlertMiddleware.initialize(server);

// Middlewares de s√©curit√© et performance
app.use(helmet({
  contentSecurityPolicy: {
    directives: {
      defaultSrc: ["'self'"],
      styleSrc: ["'self'", "'unsafe-inline'"],
      scriptSrc: ["'self'"],
      imgSrc: ["'self'", "data:", "https:"],
    },
  },
}));

app.use(compression());

// Rate limiting
const limiter = rateLimit({
  windowMs: parseInt(process.env.RATE_LIMIT_WINDOW_MS) || 15 * 60 * 1000,
  max: parseInt(process.env.RATE_LIMIT_MAX_REQUESTS) || 100,
  message: {
    success: false,
    message: 'Trop de requ√™tes, r√©essayez plus tard'
  }
});

app.use('/api/', limiter);

// Middlewares de base
app.use(express.json({ 
  limit: process.env.MAX_FILE_SIZE ? 
    parseInt(process.env.MAX_FILE_SIZE) : 
    '10mb' 
}));
app.use(express.urlencoded({ extended: true }));

// Configuration CORS
const corsOptions = {
  origin: process.env.CORS_ORIGIN?.split(',') || ['http://localhost:3001'],
  credentials: true,
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS', 'PATCH'],
  allowedHeaders: ['Content-Type', 'Authorization']
};
app.use(cors(corsOptions));

// Middleware pour injecter AlertMiddleware
app.use(injectAlertMiddleware);

// Configuration des sessions
app.use(session({
  secret: process.env.SESSION_SECRET || 'votre-session-secret-changez-moi',
  resave: false,
  saveUninitialized: false,
  store: MongoStore.create({
    mongoUrl: process.env.MONGODB_URI,
    ttl: 24 * 60 * 60
  }),
  cookie: {
    secure: process.env.NODE_ENV === 'production',
    maxAge: 24 * 60 * 60 * 1000
  }
}));

// Initialisation de Passport
app.use(passport.initialize());
app.use(passport.session());

// Connexion √† MongoDB
mongoose.connect(process.env.MONGODB_URI || 'mongodb://localhost:27017/airlight')
  .then(() => {
    console.log('‚úÖ Connexion MongoDB r√©ussie');
    
    // Initialiser le scheduler apr√®s la connexion DB
    setTimeout(() => {
      schedulerService.initialize();
    }, 2000);
  })
  .catch((error) => {
    console.error('‚ùå Erreur connexion MongoDB:', error.message);
  });

// Routes principales
app.use('/auth', authRoutes);
app.use('/alerts', alertRoutes);
app.use('/sensors', sensorRoutes);
app.use('/predictions', predictionRoutes);
app.use('/admin', adminRoutes);

// Route de sant√© compl√®te
app.get('/health', async (req, res) => {
  try {
    // V√©rifier les services
    const PredictionService = require('./services/PredictionService');
    const predictionService = new PredictionService();
    const aiHealth = await predictionService.checkAIServiceHealth();
    
    const health = {
      status: 'OK',
      timestamp: new Date(),
      services: {
        database: mongoose.connection.readyState === 1 ? 'Connected' : 'Disconnected',
        websocket: AlertMiddleware ? 'Active' : 'Inactive',
        scheduler: schedulerService.isRunning ? 'Running' : 'Stopped',
        ai_service: aiHealth.available ? 'Available' : 'Unavailable',
        connectedClients: AlertMiddleware ? AlertMiddleware.getConnectionStats().connectedClients : 0
      },
      scheduler_jobs: schedulerService.getJobsStatus(),
      ai_service_detail: aiHealth
    };
    
    const statusCode = (
      health.services.database === 'Connected' && 
      health.services.scheduler === 'Running'
    ) ? 200 : 503;
    
    res.status(statusCode).json(health);
    
  } catch (error) {
    res.status(503).json({
      status: 'ERROR',
      message: error.message,
      timestamp: new Date()
    });
  }
});

// Route principale avec documentation compl√®te
app.get('/', (req, res) => {
  res.json({
    name: 'AirLight API',
    description: 'Syst√®me intelligent de surveillance de la qualit√© de l\'air avec IA pr√©dictive',
    version: '1.0.0',
    features: [
      'üîê Authentification Google OAuth + JWT',
      'üö® Syst√®me d\'alertes temps r√©el',
      'üìä Collecte donn√©es multi-capteurs (S√©n√©gal)',
      'ü§ñ Pr√©dictions IA avec Machine Learning',
      'üì° WebSocket temps r√©el',
      'üïê Scheduler automatis√©',
      'üë®‚Äçüíº Interface administrateur'
    ],
    endpoints: {
      authentication: {
        'POST /auth/register': 'Inscription utilisateur',
        'POST /auth/login': 'Connexion email/password',
        'GET /auth/google': 'Connexion Google OAuth',
        'GET /auth/me': 'Profil utilisateur connect√©',
        'POST /auth/logout': 'D√©connexion'
      },
      sensors: {
        'GET /sensors': 'Liste des capteurs avec statuts',
        'GET /sensors/:sensorId/data': 'Donn√©es historiques d\'un capteur',
        'GET /sensors/:sensorId/latest': 'Derni√®res mesures d\'un capteur',
        'POST /sensors/data': 'Recevoir donn√©es depuis ESP32',
        'POST /sensors/sync': 'Synchroniser avec AirGradient (admin)',
        'GET /sensors/stats/global': 'Statistiques globales tous capteurs'
      },
      alerts: {
        'GET /alerts': 'Liste des alertes avec filtres',
        'GET /alerts/active': 'Alertes actives uniquement',
        'GET /alerts/stats': 'Statistiques des alertes',
        'POST /alerts/check': 'V√©rifier et cr√©er alertes',
        'PATCH /alerts/:id/acknowledge': 'Acquitter une alerte',
        'PATCH /alerts/:id/resolve': 'R√©soudre une alerte',
        'POST /alerts/bulk/acknowledge': 'Acquitter plusieurs alertes'
      },
      predictions: {
        'GET /predictions/sensors': 'Capteurs avec pr√©dictions disponibles',
        'GET /predictions/:sensorId': 'Pr√©dictions d\'un capteur',
        'POST /predictions/:sensorId/generate': 'G√©n√©rer nouvelles pr√©dictions',
        'POST /predictions/batch/generate': 'Pr√©dictions tous capteurs (admin)',
        'GET /predictions/:sensorId/accuracy': '√âvaluer pr√©cision pr√©dictions',
        'GET /predictions/stats/global': 'Statistiques globales IA',
        'GET /predictions/ai-service/health': '√âtat du service IA'
      },
      admin: {
        'GET /admin/dashboard': 'Tableau de bord administrateur',
        'GET /admin/scheduler/status': '√âtat du scheduler',
        'POST /admin/scheduler/run/:jobName': 'Ex√©cuter job manuellement',
        'POST /admin/scheduler/sync-now': 'Synchronisation forc√©e',
        'GET /admin/users': 'Gestion des utilisateurs',
        'PATCH /admin/users/:id/role': 'Modifier r√¥le utilisateur'
      },
      system: {
        'GET /health': '√âtat de sant√© complet du syst√®me',
        'GET /api/websocket/stats': 'Statistiques connexions WebSocket'
      }
    },
    websocket: {
      url: `ws://localhost:${process.env.PORT || 3000}/socket.io`,
      events: {
        client_to_server: [
          'authenticate - S\'authentifier avec token JWT',
          'subscribe_sensor - S\'abonner aux alertes d\'un capteur',
          'unsubscribe_sensor - Se d√©sabonner d\'un capteur',
          'ping - Test de connexion'
        ],
        server_to_client: [
          'authenticated - Confirmation d\'authentification',
          'new_alert - Nouvelle alerte cr√©√©e',
          'sensor_alert - Alerte sp√©cifique √† un capteur',
          'alert_resolved - Alerte r√©solue',
          'active_alerts - Liste des alertes actives',
          'system_stats - Statistiques syst√®me temps r√©el',
          'predictions_update - Nouvelles pr√©dictions disponibles',
          'pong - R√©ponse au ping'
        ]
      }
    },
    ai_predictions: {
      service_url: process.env.FLASK_API_URL || 'http://localhost:5000',
      features: [
        'Pr√©dictions PM2.5/AQI jusqu\'√† 72h',
        'Machine Learning avec Random Forest',
        '√âvaluation automatique de pr√©cision',
        'Alertes pr√©dictives intelligentes',
        'Mode d√©grad√© si service IA indisponible'
      ],
      supported_parameters: ['pm25', 'pm10', 'co2', 'temperature', 'humidity', 'tvoc', 'nox']
    },
    sensors_coverage: {
      country: 'S√©n√©gal',
      locations: [
        { name: 'Dakar', status: 'active' },
        { name: 'Saint-Louis', status: 'active' },
        { name: 'Thi√®s', status: 'active' },
        { name: 'Diourbel', status: 'active' },
        { name: 'Richard Toll', status: 'active' },
        { name: 'Rufisque', status: 'active' }
      ],
      data_sources: ['AirGradient', 'OpenAQ', 'ESP32']
    },
    scheduler_jobs: schedulerService.getJobsStatus()
  });
});

// Routes de test pour le d√©veloppement
if (process.env.NODE_ENV === 'development') {
  // Test complet du syst√®me
  app.post('/test/system', async (req, res) => {
    try {
      const results = {
        timestamp: new Date(),
        tests: {}
      };
      
      // Test base de donn√©es
      results.tests.database = {
        status: mongoose.connection.readyState === 1 ? 'OK' : 'FAIL',
        collections: await mongoose.connection.db.listCollections().toArray()
      };
      
      // Test WebSocket
      results.tests.websocket = {
        status: AlertMiddleware ? 'OK' : 'FAIL',
        clients: AlertMiddleware ? AlertMiddleware.getConnectionStats() : null
      };
      
      // Test service IA
      const PredictionService = require('./services/PredictionService');
      const predictionService = new PredictionService();
      const aiHealth = await predictionService.checkAIServiceHealth();
      results.tests.ai_service = aiHealth;
      
      // Test scheduler
      results.tests.scheduler = {
        status: schedulerService.isRunning ? 'OK' : 'FAIL',
        jobs: schedulerService.getJobsStatus()
      };
      
      res.json({
        success: true,
        message: 'Tests syst√®me effectu√©s',
        results
      });
      
    } catch (error) {
      res.status(500).json({
        success: false,
        message: 'Erreur lors des tests syst√®me',
        error: error.message
      });
    }
  });
  
  // Route pour d√©clencher une d√©mo compl√®te
  app.post('/demo/full', async (req, res) => {
    try {
      console.log('üé¨ D√©marrage d√©mo compl√®te AirLight...');
      
      const demo_results = {
        step1_data_sync: null,
        step2_alert_creation: null,
        step3_prediction_generation: null,
        step4_websocket_broadcast: null
      };
      
      // √âtape 1: Synchronisation de donn√©es
      try {
        const syncResult = await schedulerService.runJobManually('sync');
        demo_results.step1_data_sync = { success: true, result: syncResult };
      } catch (error) {
        demo_results.step1_data_sync = { success: false, error: error.message };
      }
      
      // √âtape 2: Cr√©ation d'alerte de test
      try {
        const Alert = require('./models/Alert');
        const testAlert = new Alert({
          sensorId: 'DEMO_SENSOR',
          alertType: 'pollution_spike',
          severity: 'high',
          message: 'üé¨ D√âMO - Pic de pollution d√©tect√©: PM2.5 √† 95.2 ¬µg/m¬≥',
          data: {
            currentValue: 95.2,
            threshold: 75,
            location: 'Capteur D√©mo Dakar'
          }
        });
        
        await testAlert.save();
        
        // Diffuser l'alerte
        const { triggerAlert } = require('./middleware/alertMiddleware');
        triggerAlert(testAlert);
        
        demo_results.step2_alert_creation = { success: true, alert: testAlert };
      } catch (error) {
        demo_results.step2_alert_creation = { success: false, error: error.message };
      }
      
      // √âtape 3: G√©n√©ration de pr√©dictions
      try {
        const predResult = await schedulerService.runPredictionJobManually();
        demo_results.step3_prediction_generation = { success: true, result: predResult };
      } catch (error) {
        demo_results.step3_prediction_generation = { success: false, error: error.message };
      }
      
      // √âtape 4: Diffusion stats WebSocket
      try {
        AlertMiddleware.broadcastSystemStats({
          type: 'demo_complete',
          message: 'üé¨ D√©mo AirLight termin√©e avec succ√®s',
          demo_results,
          timestamp: new Date()
        });
        
        demo_results.step4_websocket_broadcast = { success: true };
      } catch (error) {
        demo_results.step4_websocket_broadcast = { success: false, error: error.message };
      }
      
      console.log('üé¨ D√©mo compl√®te termin√©e');
      
      res.json({
        success: true,
        message: 'üé¨ D√©mo compl√®te AirLight ex√©cut√©e',
        demo_results,
        next_steps: [
          '1. V√©rifiez les alertes cr√©√©es dans /alerts',
          '2. Consultez les pr√©dictions dans /predictions/sensors',
          '3. Observez les stats temps r√©el via WebSocket',
          '4. Acc√©dez au dashboard admin dans /admin/dashboard'
        ]
      });
      
    } catch (error) {
      console.error('‚ùå Erreur d√©mo:', error);
      res.status(500).json({
        success: false,
        message: 'Erreur lors de la d√©mo',
        error: error.message
      });
    }
  });
}

// Gestion des erreurs 404
app.use((req, res) => {
  res.status(404).json({
    success: false,
    message: 'Route non trouv√©e',
    suggestion: 'Consultez la documentation sur GET /',
    available_routes: [
      '/auth/*', '/sensors/*', '/alerts/*', 
      '/predictions/*', '/admin/*', '/health'
    ]
  });
});

// Middleware de gestion des erreurs globales
app.use((error, req, res, next) => {
  console.error('‚ùå Erreur serveur:', error);
  
  // Erreurs de validation MongoDB
  if (error.name === 'ValidationError') {
    return res.status(400).json({
      success: false,
      message: 'Donn√©es invalides',
      details: Object.values(error.errors).map(e => e.message)
    });
  }
  
  // Erreurs de cast MongoDB
  if (error.name === 'CastError') {
    return res.status(400).json({
      success: false,
      message: 'Format d\'ID invalide'
    });
  }
  
  // Erreurs JWT
  if (error.name === 'JsonWebTokenError') {
    return res.status(401).json({
      success: false,
      message: 'Token invalide'
    });
  }
  
  // Erreur g√©n√©rique
  res.status(500).json({
    success: false,
    message: process.env.NODE_ENV === 'development' ? error.message : 'Erreur serveur interne'
  });
});

// Gestion de l'arr√™t gracieux
process.on('SIGTERM', gracefulShutdown);
process.on('SIGINT', gracefulShutdown);

function gracefulShutdown(signal) {
  console.log(`\nüì¥ Signal ${signal} re√ßu, arr√™t gracieux...`);
  
  // Arr√™ter le scheduler
  schedulerService.stopAll();
  
  // Fermer le serveur
  server.close(() => {
    console.log('üîå Serveur HTTP ferm√©');
    
    // Fermer la connexion MongoDB
    mongoose.connection.close(false, () => {
      console.log('üóÑÔ∏è Connexion MongoDB ferm√©e');
      process.exit(0);
    });
  });
  
  // Forcer l'arr√™t apr√®s 10 secondes
  setTimeout(() => {
    console.error('‚ö†Ô∏è Arr√™t forc√© apr√®s timeout');
    process.exit(1);
  }, 10000);
}

// D√©marrage du serveur
const PORT = process.env.PORT || 3000;
server.listen(PORT, () => {
  console.log('\nüöÄ =================================');
  console.log('üåü AirLight API d√©marr√©e avec succ√®s');
  console.log('üöÄ =================================');
  console.log(`üì° Serveur: http://localhost:${PORT}`);
  console.log(`üîó Google OAuth: ${process.env.GOOGLE_CALLBACK_URL || 'Non configur√©'}`);
  console.log(`üåê WebSocket: ws://localhost:${PORT}/socket.io`);
  console.log(`ü§ñ Service IA: ${process.env.FLASK_API_URL || 'http://localhost:5000'}`);
  console.log(`üìä Dashboard: http://localhost:${PORT}/admin/dashboard`);
  console.log(`üè• Sant√©: http://localhost:${PORT}/health`);
  
  if (process.env.NODE_ENV === 'development') {
    console.log(`üé¨ D√©mo: http://localhost:${PORT}/demo/full`);
    console.log('üîß Mode d√©veloppement - Routes de test disponibles');
  }
  
  console.log('üöÄ =================================\n');
});

module.exports = server;